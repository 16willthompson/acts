// STL include(s)
//#include <algorithm>
#include <utility>

namespace Acts
{
  /// @cond DEV
  namespace
  {
    /// @cond
    // one value is always sorted
    template<bool ascending, bool strict, typename T, T v>
    struct are_sorted<ascending, strict, T, v>
    {
      enum
      {
        value = true
      };
    };

    // strict, ascending ordering
    template<typename T, T a, T b, T ... N>
    struct are_sorted<true, true, T, a, b, N...>
    {
      enum
      {
        value = (a<b && are_sorted < true, true, T, b, N...>::value)
      };
    };

    // weak, ascending ordering
    template<typename T, T a, T b, T ... N>
    struct are_sorted<true, false, T, a, b, N...>
    {
      enum
      {
        value = (a <= b && are_sorted<true, false, T, b, N...>::value)
      };
    };

    // strict, descending ordering
    template<typename T, T a, T b, T ... N>
    struct are_sorted<false, true, T, a, b, N...>
    {
      enum
      {
        value = (a > b && are_sorted<false, true, T, b, N...>::value)
      };
    };

    // weak, descending ordering
    template<typename T, T a, T b, T ... N>
    struct are_sorted<false, false, T, a, b, N...>
    {
      enum
      {
        value = (a >= b && are_sorted<false, false, T, b, N...>::value)
      };
    };
    /// @endcond

    /// @cond
    // check last parameter
    template<typename T, T MIN, T MAX, T a>
    struct are_within<T,MIN,MAX,a>
    {
      enum
      {
        value = (a >= MIN && a < MAX)
      };
    };

    // recursive check
    template<typename T, T MIN, T MAX, T a, T... others>
    struct are_within<T,MIN,MAX,a,others...>
    {
      enum
      {
        value = (a >= MIN && a < MAX && are_within<T,MIN,MAX,others...>::value)
      };
    };
    /// @endcond

    /**
     * @brief  initialize projection matrices
     *
     * This struct provides an initialization method for a projection matrix M such that only
     * the entries with the given indices are selected from a full parameter vector. That means,
     * M is a mapping M: (Nx1) --> (Sx1) if N is the total number of parameters and S is the
     * number of given indices.
     *
     * @tparam columns number of columns (= dimension of full parameter space)
     * @tparam rows template parameter pack containing the indices of the parameters to be projected
     *
     * @return `make_projection_matrix<columns,rows...>::init()` returns a matrix with dimensions
     *         (`sizeof...(rows)` x columns)
     */
    template<unsigned int columns, unsigned int... rows>
    struct make_projection_matrix;

    /// @cond
    // build projection matrix by iteratively stacking row vectors
    template<unsigned int columns, unsigned int i, unsigned int ... N>
    struct make_projection_matrix<columns, i, N...>
    {
      static ActsMatrixD<sizeof...(N) + 1, columns> init()
      {
        ActsRowVectorD < columns > v;
        v.setZero();
        v(i) = 1;

        ActsMatrixD < sizeof...(N) + 1, columns > m;
        m.row(0) << v;
        m.block(1, 0, sizeof...(N), columns) << make_projection_matrix<columns, N...>::init();

        return m;
      }
    };

    // projection matrix for a single local parameter is a simple row vector
    template<unsigned int columns, unsigned int i>
    struct make_projection_matrix<columns, i>
    {
      static ActsRowVectorD<columns> init()
      {
        ActsRowVectorD<columns> v;
        v.setZero();
        v(i) = 1;
        return v;
      }
    };
    /// @endcond

    /**
     * @brief get position of integral constant in template parameter pack
     *
     * @tparam T integral type of the values to be investigated
     * @tparam target target value whose position in the template parameter pack should be determined
     * @tparam values template parameter pack containing the list of values
     *
     * @return `get_position<T,target,values...>::value` yields the position of `target` inside `values`.
     *         If `target` is not in the list of `values`, a compile-time error is generated.
     */
    template<typename T, T target, T ... values>
    struct get_position;

    /// @cond
    template<typename T, T target, T ... others>
    struct get_position<T, target, target, others...>
    {
      enum
      {
        value = 0
      };
    };

    template<typename T, T target, T next, T ... others>
    struct get_position<T, target, next, others...>
    {
      enum
      {
        value = get_position<T, target, others...>::value + 1
      };
    };
    /// @endcond

    /**
     * @brief check whether given integral constant is contained in a template parameter pack
     *
     * @tparam T integral type of the values to be checked
     * @tparam target target value to be looked for
     * @tparam values template parameter pack containing the list of values
     *
     * @return `is_contained<T,target,values...>::value` is @c true if `target` is among `values`, otherwise @c false
     */
    template<typename T, T target, T... values>
    struct is_contained;

    /// @cond
    template<typename T, T target, T ... others>
    struct is_contained<T, target, target, others...>
    {
      enum
      {
        value = true
      };
    };

    template<typename T, T target>
    struct is_contained<T, target, target>
    {
      enum
      {
        value = true
      };
    };

    template<typename T, T target, T next, T ... others>
    struct is_contained<T, target, next, others...>
    {
      enum
      {
        value = is_contained<T, target, others...>::value
      };
    };

    template<typename T, T target, T next>
    struct is_contained<T, target, next>
    {
      enum
      {
        value = false
      };
    };
    /// @endcond

    /**
     * @brief initialize parameter set with given parameter values
     *
     * @note uses the templated ParameterSet::set method for assigning the individual components
     *
     * Possible invocations are:
     * * `initialise<T,params...>::init(parSet,values...)` where `parSet` is the ParameterSet object to be
     *    initialised and `values` are a consistent number of parameter values (with compatible type)
     * * `initialise<T,params...>::init(parSet,values)` where `parSet` is the ParameterSet object to be
     *    initialised and `values` is an Eigen vector of consistent size
     *
     * @tparam T type of the parameters stored in the corresponding @c ParameterSet class
     * @tparam params template parameter pack containing the multiple identifiers
     */
    template<typename T, T... params>
    struct initialise;

    /// @cond
    template<typename T,T first,T... others>
    struct initialise<T,first,others...>
    {
      template<typename ParSetType,typename first_value_type,typename... other_value_types>
      static void init(ParSetType& parSet,const first_value_type& v1, const other_value_types&... values)
      {
        parSet.template setParameter<first>(v1);
        initialise<T,others...>::init(parSet,values...);
      }

      template<typename ParSetType>
      static void init(ParSetType& parSet,const typename ParSetType::ParVector_t& values, const unsigned int& pos = 0)
      {
        parSet.template setParameter<first>(values(pos));
        initialise<T,others...>::init(parSet,values,pos+1);
      }
    };

    template<typename T,T last>
    struct initialise<T,last>
    {
      template<typename ParSet_tType,typename last_value_type>
      static void init(ParSet_tType& ParSet_t,const last_value_type& v1)
      {
        ParSet_t.template setParameter<last>(v1);
      }

      template<typename ParSetType>
      static void init(ParSetType& parSet,const typename ParSetType::ParVector_t& values, const unsigned int& pos = 0)
      {
        parSet.template setParameter<last>(values(pos));
      }
    };
    /// @endcond

    /**
     * @brief calculate residuals from two parameter vectors
     *
     * Calculate the difference between the two given vectors with parameter values. Possible
     * corrections for bounded or cyclic parameters are applied.
     *
     * @tparam Policy struct/class defining the parameter definitions
     * @tparam params template parameter pack containing the multiple parameter identifiers
     *
     * @return `residual_calculator<Policy,params...>::result(first,second)` yields the residuals of
     *         `first` with respect to `second`
     */
    template<ParID_t... params>
    struct residual_calculator;

    /// @cond
    template<typename R,ParID_t... params>
    struct residual_calculator_impl;

    template<ParID_t... params>
    struct residual_calculator
    {
      typedef ActsVector<ParValue_t,sizeof...(params)> ParVector_t;

      static ParVector_t result(const ParVector_t& test,const ParVector_t& ref)
      {
        ParVector_t result;
        residual_calculator_impl<ParVector_t,params...>::calculate(result,test,ref,0);
        return result;
      }
    };

    template<typename R, ParID_t first,ParID_t... others>
    struct residual_calculator_impl<R,first,others...>
    {
      static void calculate(R& result,const R& test,const R& ref,unsigned int pos)
      {
        typedef typename par_type<first>::type parameter_type;
        result(pos) = parameter_type::getDifference(test(pos),ref(pos));
        residual_calculator_impl<R,others...>::calculate(result,test,ref,pos+1);
      }
    };

    template<typename R,ParID_t last>
    struct residual_calculator_impl<R,last>
    {
      static void calculate(R& result,const R& test,const R& ref,unsigned int pos)
      {
        typedef typename par_type<last>::type parameter_type;
        result(pos) = parameter_type::getDifference(test(pos),ref(pos));
      }
    };
    /// @endcond

    /**
     * @brief check and correct parameter values
     *
     * Values in the given vector are interpreted as values for the given parameters. As those
     * they are checked whether they are inside the allowed range and corrected if necessary.
     *
     * Invocation:
     *   - `value_corrector<Policy,params...>::result(parVector)` where `parVector` contains
     *     `sizeof...(params)` elements
     *
     * @post All values in the argument `parVector` are within the valid parameter range.
     *
     * @tparam Policy struct/class defining the parameter definitions
     * @tparam params template parameter pack containing the multiple parameter identifiers
     */
    template<ParID_t... params>
    struct value_corrector;

    /// @cond
    template<typename R,ParID_t... params>
    struct value_corrector_impl;

    template<ParID_t... params>
    struct value_corrector
    {
      typedef ActsVector<ParValue_t,sizeof...(params)> ParVector_t;

      static void result(ParVector_t& values)
      {
        value_corrector_impl<ParVector_t,params...>::calculate(values,0);
      }
    };

    template<typename R, ParID_t first,ParID_t... others>
    struct value_corrector_impl<R,first,others...>
    {
      static void calculate(R& values,unsigned int pos)
      {
        typedef typename par_type<first>::type parameter_type;
        if(parameter_type::may_modify_value)
          values(pos) = parameter_type::getValue(values(pos));
        value_corrector_impl<R,others...>::calculate(values,pos+1);
      }
    };

    template<typename R,ParID_t last>
    struct value_corrector_impl<R,last>
    {
      static void calculate(R& values,unsigned int pos)
      {
        typedef typename par_type<last>::type parameter_type;
        if(parameter_type::may_modify_value)
          values(pos) = parameter_type::getValue(values(pos));
      }
    };
    /// @endcond

  } // end of anonymous namespace
  /// @endcond

  // initialize static class members
  template<ParID_t ... params>
  const typename ParameterSet<params...>::Projection_t ParameterSet<params...>::sProjector =
      make_projection_matrix<Acts::NGlobalPars, static_cast<unsigned int>(params)...>::init();

  // constructor
  template<ParID_t ... params>
  template<typename ... Tail>
  ParameterSet<params...>::ParameterSet(Cov_uptr cov,std::enable_if_t<sizeof...(Tail) + 1 == NPars,ParValue_t> head, Tail ... values):
   m_vValues(NPars),
   m_pCovariance(std::move(cov))
  {
    initialise<ParID_t,params...>::init(*this,head,values...);
  }

  // constructor
  template<ParID_t ... params>
  ParameterSet<params...>::ParameterSet(Cov_uptr cov,const ParVector_t& values):
   m_vValues(NPars),
   m_pCovariance(std::move(cov))
  {
    initialise<ParID_t,params...>::init(*this,values);
  }

  // copy constructor
  template<ParID_t ... params>
  ParameterSet<params...>::ParameterSet(const ParameterSet<params...>& copy):
    m_vValues(copy.m_vValues),
    m_pCovariance(nullptr)
  {
    if(copy.m_pCovariance)
      m_pCovariance.reset(new CovMatrix_t(*copy.m_pCovariance));
  }

  // move constructor
  template<ParID_t ... params>
  ParameterSet<params...>::ParameterSet(ParameterSet<params...>&& copy):
    m_vValues(std::move(copy.m_vValues)),
    m_pCovariance(std::move(copy.m_pCovariance))
  {}

  // copy assignment operator
  template<ParID_t ... params>
  ParameterSet<params...>& ParameterSet<params...>::operator=(const ParSet_t& rhs)
  {
    m_vValues = rhs.m_vValues;
    m_pCovariance.reset(rhs.m_pCovariance ? new CovMatrix_t(*rhs.m_pCovariance): nullptr);

    return *this;
  }

  // move assignment operator
  template<ParID_t ... params>
  ParameterSet<params...>& ParameterSet<params...>::operator=(ParSet_t&& rhs)
  {
    m_vValues = std::move(rhs.m_vValues);
    m_pCovariance = std::move(rhs.m_pCovariance);
    return *this;
  }

  // parameter accessor
  template<ParID_t ... params>
  template<ParID_t parameter>
  ParValue_t ParameterSet<params...>::getParameter() const
  {
    return m_vValues(get_position<ParID_t, parameter, params...>::value);
  }

  // parameter accessor
  template<ParID_t ... params>
  typename ParameterSet<params...>::ParVector_t ParameterSet<params...>::getParameters() const
  {
    return m_vValues;
  }

  // parameter setter
  template<ParID_t ... params>
  template<ParID_t parameter>
  void ParameterSet<params...>::setParameter(ParValue_t value)
  {
    typedef typename par_type<parameter>::type parameter_type;
    m_vValues(get_position<ParID_t, parameter, params...>::value) = parameter_type::getValue(value);
  }

  // parameter setter
  template<ParID_t ... params>
  void ParameterSet<params...>::setParameters(const ParVector_t& values)
  {
    initialise<ParID_t,params...>::init(*this,values);
  }

  // covariance getter
  template<ParID_t ... params>
  const typename ParameterSet<params...>::CovMatrix_t* ParameterSet<params...>::getCovariance() const
  {
    return m_pCovariance.get();
  }

  // uncertainty getter
  template<ParID_t ... params>
  template<ParID_t parameter>
  ParValue_t ParameterSet<params...>::uncertainty() const
  {
    if(m_pCovariance)
    {
      const unsigned int iPos = get_position<ParID_t, parameter, params...>::value;
      return sqrt((*m_pCovariance)(iPos,iPos));
    }
    else
      return -1.;
  }

  // covariance setter
  template<ParID_t ... params>
  void ParameterSet<params...>::setCovariance(Cov_uptr cov)
  {
    m_pCovariance = std::move(cov);
  }

  // parameter query
  template<ParID_t ... params>
  template<ParID_t parameter>
  bool ParameterSet<params...>::contains() const
  {
    return is_contained<ParID_t, parameter, params...>::value;
  }

  // equality operator
  template<ParID_t ... params>
  bool ParameterSet<params...>::operator==(const ParSet_t& rhs) const
  {
    // shortcut comparison with myself
    if(&rhs == this)
      return true;

    // parameter values
    if(m_vValues != rhs.m_vValues)
      return false;
    // both have covariance matrices set
    if((m_pCovariance && rhs.m_pCovariance) && (*m_pCovariance != *rhs.m_pCovariance))
      return false;
    // only one has a covariance matrix set
    if((m_pCovariance && !rhs.m_pCovariance) || (!m_pCovariance && rhs.m_pCovariance))
      return false;

    return true;
  }

  // projection
  template<ParID_t ... params>
  typename ParameterSet<params...>::ParVector_t ParameterSet<params...>::project(const FullParameterSet& fullParSet) const
  {
    return projector() * fullParSet.getParameters();
  }

  // residual calculation
  template<ParID_t ... params>
  template<typename T,std::enable_if_t<not std::is_same<T,FullParameterSet>::value,int> >
  typename ParameterSet<params...>::ParVector_t ParameterSet<params...>::residual(const FullParameterSet& fullParSet) const
  {
    return residual_calculator<params...>::result(m_vValues,projector() * fullParSet.getParameters());
  }

  // residual calculation
  template<ParID_t ... params>
  typename ParameterSet<params...>::ParVector_t ParameterSet<params...>::residual(const ParSet_t& otherParSet) const
  {
    return residual_calculator<params...>::result(m_vValues,otherParSet.m_vValues);
  }

  // parameter value correction
  template<ParID_t ... params>
  void ParameterSet<params...>::correctValues(ParVector_t& values)
  {
    value_corrector<params...>::result(values);
  }
} // end of namespace Acts
