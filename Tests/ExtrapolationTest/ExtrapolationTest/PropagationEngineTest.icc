// Root includes
#include "TTree.h"
#include "TString.h"
// Core module
#include "Algebra/StringConverters.h"
#include "Algebra/AlgebraHelper.h"
// EventData modules
#include "TrackParameters/TrackParameters.h"
#include "NeutralParameters/NeutralParameters.h"
#include "EventDataUtils/ParticleHypothesis.h"
#include "Detector/Layer.h"

template <class T> const T* Acts::PropagationEngineTest::executeTestT(const T& startParameters, const Surface& surface)
{
  
    m_startPositionX = startParameters.position().x();
    m_startPositionY = startParameters.position().y();
    m_startPositionZ = startParameters.position().z();
    m_startPositionR = startParameters.position().perp();
      
    // screen output
    MSG_DEBUG("===> forward propagation - collecting information <<===");

    ExtrapolationCell<T> eCell(startParameters);
    
    ExtrapolationCode eCode = m_propagationEngine->propagate(eCell,
                                                             surface,
                                                             alongMomentum,
                                                             true,
                                                             m_returnCurvilinear);
                                                             
    if (m_emulatePlaneSurfaces && eCell.leadParameters){
        // construct a plane surface as a tangent (but move it a little bit)
        const Vector3D& cIntersection =  eCell.leadParameters->position();
        // create a new transform
        double modulePhi = cIntersection.phi();
        double modulePhiTilt = 0.2;
        // shift the module a little bit 
        Acts::Vector3D moduleCenter = cIntersection + Vector3D(1.,1.,1.);
        // normal vectorof the surface
        Acts::Vector3D moduleLocalZ(cos(modulePhi+modulePhiTilt),sin(modulePhi+modulePhiTilt), 0.);
        Acts::Vector3D moduleLocalY(0.,0.,1);
        Acts::Vector3D moduleLocalX(-sin(modulePhi+modulePhiTilt),cos(modulePhi+modulePhiTilt),0.);
        // create the RotationMatrix
        Acts::RotationMatrix3D moduleRotation;
        moduleRotation.col(0) = moduleLocalX;
        moduleRotation.col(1) = moduleLocalY;
        moduleRotation.col(2) = moduleLocalZ;
        // get the moduleTransform
        std::shared_ptr<Acts::Transform3D> moduleTransform(new Acts::Transform3D(Acts::getTransformFromRotTransl(moduleRotation,moduleCenter)));
        
        // now you can delete the leadParameters
        delete eCell.leadParameters;
        
        eCell = ExtrapolationCell<T>(startParameters);
        
        // create the surface
        // @TODO memory management screwed up !
        PlaneSurface psf(moduleTransform);
        
        eCode = m_propagationEngine->propagate(eCell,
                                               psf,
                                               alongMomentum,
                                               true,
                                               m_returnCurvilinear);
                                               
    }                                                             

    // save the success code
    m_endSuccessful = int(eCode.code);
    // end parameters from the extrapolation cell
    const T* endParameters = eCell.leadParameters;
    // end the parameters if there
    if (endParameters){
        m_endPositionX  = endParameters->position().x();
        m_endPositionY  = endParameters->position().y();
        m_endPositionZ  = endParameters->position().z();
        m_endPositionR  = endParameters->position().perp();
        m_endPhi        = endParameters->momentum().phi();  
        m_endEta        = endParameters->momentum().eta();
        m_endTheta      = endParameters->momentum().theta();   
        m_endP          = endParameters->momentum().mag();
        m_endPt         = endParameters->momentum().perp();
        m_endPathLength = eCell.pathLength;

        // do the back extrapolation
        if (m_backPropagation){
            // screen output
            MSG_DEBUG("===> backward propagation - collecting information <<===");
            // eCell backwd    
            ExtrapolationCell<T> eCellBwd(*endParameters);
            // safe the success code
            ExtrapolationCode eCodeBwd = m_propagationEngine->propagate(eCellBwd,
                                                                        startParameters.associatedSurface(),
                                                                        oppositeMomentum,
                                                                        true,
                                                                        m_returnCurvilinear);
            // save the success code
            m_backSuccessful = int(eCodeBwd.code);
            // end parameters from the extrapolation cell
            const T* endParametersBwd = eCellBwd.leadParameters;
            // end the parameters if there
            if (endParametersBwd){
                m_backPositionX  = endParametersBwd->position().x();
                m_backPositionY  = endParametersBwd->position().y();
                m_backPositionZ  = endParametersBwd->position().z();
                m_backPositionR  = endParametersBwd->position().perp();
                m_backPhi        = endParametersBwd->momentum().phi();  
                m_backEta        = endParametersBwd->momentum().eta();
                m_backTheta      = endParametersBwd->momentum().theta();   
                m_backP          = endParametersBwd->momentum().mag();
                m_backPt         = endParametersBwd->momentum().perp();
                // delete what you have
                delete endParametersBwd;                                                                                                                                    
            }
        }
        // now clean up the first end parameters
        m_tree->Fill();
        return endParameters;
    } else {
        MSG_WARNING("Propagation was not Successful - code : " << eCode.toString() << " -> Printing start parameters.");
        MSG_WARNING("    -> start x     = " << m_startPositionX );
        MSG_WARNING("    -> start y     = " << m_startPositionY );
        MSG_WARNING("    -> start z     = " << m_startPositionZ  );
        MSG_WARNING("    -> start r     = " << m_startPositionR );
        MSG_WARNING("    -> start phi   = " << m_startPhi       );
        MSG_WARNING("    -> start eta   = " << m_startEta       );
        MSG_WARNING("    -> start theta = " << m_startTheta     );
        MSG_WARNING("    -> start pt    = " << m_startPt        );
        MSG_WARNING("    -> start p     = " << m_startP         );
    }
    return nullptr;
}
