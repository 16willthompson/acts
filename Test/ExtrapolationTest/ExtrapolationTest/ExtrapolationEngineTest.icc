// Root includes
#include "TTree.h"
#include "TString.h"
// Core module
#include "Algebra/StringConverters.h"
// EventData modules
#include "TrackParameters/TrackParameters.h"
#include "NeutralParameters/NeutralParameters.h"
#include "EventDataUtils/ParticleHypothesis.h"
#include "Detector/Layer.h"

template <class T> StatusCode Ats::ExtrapolationEngineTest::executeTestT(const T& startParameters)
{
  
    m_startPositionX = startParameters.position().x();
    m_startPositionY = startParameters.position().y();
    m_startPositionZ = startParameters.position().z();
    m_startPositionR = startParameters.position().perp();
  
    // setup the extrapolation how you'd like it
    Ats::ExtrapolationCell<T> ecc(startParameters);
    ecc.setParticleHypothesis((Ats::ParticleHypothesis)m_particleHypothesis);
    //ecc.addConfigurationMode(Ats::ExtrapolationMode::StopAtBoundary);
    ecc.addConfigurationMode(Ats::ExtrapolationMode::FATRAS);	
    if (m_collectSensitive) ecc.addConfigurationMode(Ats::ExtrapolationMode::CollectSensitive);
    if (m_collectPassive)   ecc.addConfigurationMode(Ats::ExtrapolationMode::CollectPassive);
    if (m_collectBoundary)  ecc.addConfigurationMode(Ats::ExtrapolationMode::CollectBoundary);
    if (m_collectMaterial)  ecc.addConfigurationMode(Ats::ExtrapolationMode::CollectMaterial);
    if (m_roboustSearch)    ecc.addConfigurationMode(Ats::ExtrapolationMode::RobustSearch);
    
    // force a stop in the extrapoaltion mode
    if (m_pathLimit > 0.) {
        ecc.pathLimit = m_pathLimit;
        ecc.addConfigurationMode(Ats::ExtrapolationMode::StopWithPathLimit);
    }
    // screen output
    MSG_DEBUG("===> forward extrapolation - collecting information <<===");
    // call the extrapolation engine
    Ats::ExtrapolationCode eCode = m_extrapolationEngine->extrapolate(ecc);
    // save the success code
    m_endSuccessful= int(eCode.code);
    // end the parameters if there
    if (eCode.isSuccess() && ecc.endParameters){
        m_endPositionX  = ecc.endParameters->position().x();
        m_endPositionY  = ecc.endParameters->position().y();
        m_endPositionZ  = ecc.endParameters->position().z();
        m_endPositionR  = ecc.endParameters->position().perp();
        m_endPhi        = ecc.endParameters->momentum().phi();  
        m_endEta        = ecc.endParameters->momentum().eta();
        m_endTheta      = ecc.endParameters->momentum().theta();   
        m_endP          = ecc.endParameters->momentum().mag();
        m_endPt         = ecc.endParameters->momentum().perp();
        m_endPathLength = ecc.pathLength;
        // fill in the step parameters
        if (!fillStepInformationT<T>(ecc,1).isSuccess()) 
            MSG_VERBOSE("Somthing went wrong with recording the step information.");    
        // for the memory cleanup
        const T* feParameters = ecc.endParameters;
        // do the back extrapolation
        if (m_backExtrapolation){
            // let's restart at the destination
            ecc.restartAtDestination();
            // screen output
            MSG_DEBUG("===> backward extrapolation - collecting information <<===");
            // call the extrapolation engine
            Ats::ExtrapolationCode eCodeBwd = m_extrapolationEngine->extrapolate(ecc,&startParameters.associatedSurface());
            // safe the success code
            m_backSuccessful= int(eCodeBwd.code);
            // end the parameters if there
            if (eCodeBwd.isSuccess() && ecc.endParameters){
                m_backPositionX = ecc.endParameters->position().x();
                m_backPositionY = ecc.endParameters->position().y();
                m_backPositionZ = ecc.endParameters->position().z();
                m_backPositionR = ecc.endParameters->position().perp();
                m_backPhi       = ecc.endParameters->momentum().phi();  
                m_backEta       = ecc.endParameters->momentum().eta();
                m_backTheta     = ecc.endParameters->momentum().theta();   
                m_backP         = ecc.endParameters->momentum().mag();
                m_backPt        = ecc.endParameters->momentum().perp();
                // fill in the step parameters
                if (!fillStepInformationT<T>(ecc,-1).isSuccess()) 
                    MSG_VERBOSE("Somthing went wrong with recording the step information."); 
                // memory cleanup
                delete ecc.endParameters;
            }
        }
        // now clean up the first end parameters
        delete feParameters;
    } else {
        MSG_WARNING("Extrapolation was not Successful - code : " << eCode.toString() << " -> Printing start parameters.");
        MSG_WARNING("    -> start x     = " << m_startPositionX );
        MSG_WARNING("    -> start y     = " << m_startPositionY );
        MSG_WARNING("    -> start z     = " << m_startPositionZ  );
        MSG_WARNING("    -> start r     = " << m_startPositionR );
        MSG_WARNING("    -> start phi   = " << m_startPhi       );
        MSG_WARNING("    -> start eta   = " << m_startEta       );
        MSG_WARNING("    -> start theta = " << m_startTheta     );
        MSG_WARNING("    -> start pt    = " << m_startPt        );
        MSG_WARNING("    -> start p     = " << m_startP         );
    }
    return StatusCode::SUCCESS;
}

template <class T> StatusCode Ats::ExtrapolationEngineTest::fillStepInformationT(Ats::ExtrapolationCell<T>& ecc, int fwdBwd) 
{
    //// loop over the collected information
    for (auto& es : ecc.extrapolationSteps){
       // continue if we have parameters
       const T* parameters = es.parameters;
       if (parameters){
           // there are parameters assigned, so they need to be either 
           // sensitive -> ip = 0
           // passive   -> ip = 1
           // boundary  -> ip = 2
           unsigned int ip = 0;
           if (es.stepConfiguration.checkMode(Ats::ExtrapolationMode::CollectPassive)){
               ip = 1;
           } else if (es.stepConfiguration.checkMode(Ats::ExtrapolationMode::CollectBoundary)){
               ip = 2;
           }   
           // fill the parameters    
           m_pPositionX[ip]->push_back(parameters->position().x());
           m_pPositionY[ip]->push_back(parameters->position().y());
           m_pPositionZ[ip]->push_back(parameters->position().z());
           m_pPositionR[ip]->push_back(parameters->position().perp());
           m_pPhi[ip]->push_back(parameters->momentum().phi());  
           m_pTheta[ip]->push_back(parameters->momentum().eta());
           m_pEta[ip]->push_back(parameters->momentum().theta()); 
           m_pP[ip]->push_back(parameters->momentum().mag());
           m_pPt[ip]->push_back(parameters->momentum().perp());
    
        }
    }
    return StatusCode::SUCCESS;
}    
